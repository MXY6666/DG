% The isoparametric mapping form reference cube to a hexahedron with
% vertices (x_i, y_i), i = 1, \cdots, 8 is
% (x, y, z) = \sum{i = 1}^{8}(x_i, y_i, z_i)N_i(\xi, \eta, \zeta), 
% where
% N_1 = (1 - \xi)(1 - \eta)(1 - \zeta) / 8, 
% N_2 = (1 + \xi)(1 - \eta)(1 - \zeta) / 8,
% N_3 = (1 + \xi)(1 + \eta)(1 - \zeta) / 8, 
% N_4 = (1 - \xi)(1 + \eta)(1 - \zeta) / 8,
% N_5 = (1 - \xi)(1 - \eta)(1 + \zeta) / 8, 
% N_6 = (1 + \xi)(1 - \eta)(1 + \zeta) / 8,
% N_7 = (1 + \xi)(1 + \eta)(1 + \zeta) / 8, 
% N_8 = (1 - \xi)(1 + \eta)(1 + \zeta) / 8,
% Note, the points stored in quad are actually not the Gauss points in the
% physical hexahedron, but we can get it through 
% quad.N * (x1, y1; x2, y2; ...; x8, y8) as long as the coordinates of
% the hexahedral vertices are provided
% Copyright (C) Xiangyi Meng.

function quad = GaussQuadratureRule_hexa(np, type)

quad = GaussQuadratureRule_cube(np, type);

quad.N = 0.125 * [(1 - quad.points(:, 1)) .* (1 - quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                  (1 + quad.points(:, 1)) .* (1 - quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                  (1 + quad.points(:, 1)) .* (1 + quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                  (1 - quad.points(:, 1)) .* (1 + quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                  (1 - quad.points(:, 1)) .* (1 - quad.points(:, 2)) .* (1 + quad.points(:, 3)), ...
                  (1 + quad.points(:, 1)) .* (1 - quad.points(:, 2)) .* (1 + quad.points(:, 3)), ...
                  (1 + quad.points(:, 1)) .* (1 + quad.points(:, 2)) .* (1 + quad.points(:, 3)), ...
                  (1 - quad.points(:, 1)) .* (1 + quad.points(:, 2)) .* (1 + quad.points(:, 3))];
              
quad.N_xi = 0.125 * [-(1 - quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                     +(1 - quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                     +(1 + quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                     -(1 + quad.points(:, 2)) .* (1 - quad.points(:, 3)), ...
                     -(1 - quad.points(:, 2)) .* (1 + quad.points(:, 3)), ...
                     +(1 - quad.points(:, 2)) .* (1 + quad.points(:, 3)), ...
                     +(1 + quad.points(:, 2)) .* (1 + quad.points(:, 3)), ...
                     -(1 + quad.points(:, 2)) .* (1 + quad.points(:, 3))]; 
                 
quad.N_eta = 0.125 * [-(1 - quad.points(:, 1)) .* (1 - quad.points(:, 3)), ...
                      -(1 + quad.points(:, 1)) .* (1 - quad.points(:, 3)), ...
                      +(1 + quad.points(:, 1)) .* (1 - quad.points(:, 3)), ...
                      +(1 - quad.points(:, 1)) .* (1 - quad.points(:, 3)), ...
                      -(1 - quad.points(:, 1)) .* (1 + quad.points(:, 3)), ...
                      -(1 + quad.points(:, 1)) .* (1 + quad.points(:, 3)), ...
                      +(1 + quad.points(:, 1)) .* (1 + quad.points(:, 3)), ...
                      +(1 - quad.points(:, 1)) .* (1 + quad.points(:, 3))];
                 
quad.N_zeta = 0.125 * [-(1 - quad.points(:, 1)) .* (1 - quad.points(:, 2)), ...
                       -(1 + quad.points(:, 1)) .* (1 - quad.points(:, 2)), ...
                       -(1 + quad.points(:, 1)) .* (1 + quad.points(:, 2)), ...
                       -(1 - quad.points(:, 1)) .* (1 + quad.points(:, 2)), ...
                       +(1 - quad.points(:, 1)) .* (1 - quad.points(:, 2)), ...
                       +(1 + quad.points(:, 1)) .* (1 - quad.points(:, 2)), ...
                       +(1 + quad.points(:, 1)) .* (1 + quad.points(:, 2)), ...
                       +(1 - quad.points(:, 1)) .* (1 + quad.points(:, 2))];                 


end



